'use strict';

var unixfsEngine = require('ipfs-unixfs-engine');
var Importer = unixfsEngine.Importer;
var Exporter = unixfsEngine.Exporter;
var UnixFS = require('ipfs-unixfs');
var through = require('through2');
var isStream = require('isstream');
var promisify = require('promisify-es6');
var Duplex = require('stream').Duplex;
var multihashes = require('multihashes');

module.exports = function files(self) {
  return {
    createAddStream: function createAddStream(callback) {
      var i = new Importer(self._dagS);
      var ds = new Duplex({ objectMode: true });

      ds._read = function (n) {};
      ds._write = function (file, enc, next) {
        i.write(file);
        next();
      };

      ds.end = function () {
        i.end();
      };

      var counter = 0;

      i.on('data', function (file) {
        counter++;
        self.object.get(file.multihash, function (err, node) {
          if (err) {
            return ds.emit('error', err);
          }
          ds.push({ path: file.path, node: node });
          counter--;
        });
      });

      i.on('end', function () {
        function canFinish() {
          if (counter === 0) {
            ds.push(null);
          } else {
            setTimeout(canFinish, 100);
          }
        }
        canFinish();
      });

      callback(null, ds);
    },
    add: promisify(function (data, callback) {
      // Buffer input
      if (Buffer.isBuffer(data)) {
        data = [{
          path: '',
          content: data
        }];
      }
      // Readable stream input
      if (isStream.isReadable(data)) {
        data = [{
          path: '',
          content: data
        }];
      }
      if (!callback || typeof callback !== 'function') {
        callback = function noop() {};
      }
      if (!Array.isArray(data)) {
        return callback(new Error('"data" must be an array of { path: string, content: Buffer|Readable } or Buffer or Readable'));
      }

      var i = new Importer(self._dagS);
      var res = [];

      // Transform file info tuples to DAGNodes
      i.pipe(through.obj(function (info, enc, next) {
        var mh = multihashes.toB58String(info.multihash);
        self._dagS.get(mh, function (err, node) {
          if (err) return callback(err);
          var obj = {
            path: info.path || mh,
            node: node
          };
          res.push(obj);
          next();
        });
      }, function (done) {
        callback(null, res);
      }));

      data.forEach(function (tuple) {
        i.write(tuple);
      });

      i.end();
    }),

    cat: promisify(function (hash, callback) {
      if (typeof hash === 'function') {
        return callback(new Error('You must supply a multihash'));
      }
      self._dagS.get(hash, function (err, fetchedNode) {
        if (err) {
          return callback(err);
        }
        var data = UnixFS.unmarshal(fetchedNode.data);
        if (data.type === 'directory') {
          callback(new Error('This dag node is a directory'));
        } else {
          var exportStream = Exporter(hash, self._dagS);
          exportStream.once('data', function (object) {
            callback(null, object.content);
          });
        }
      });
    }),

    get: promisify(function (hash, callback) {
      var exportFile = Exporter(hash, self._dagS);
      callback(null, exportFile);
    })
  };
};