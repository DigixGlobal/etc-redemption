'use strict';

var peerId = require('peer-id');
var multiaddr = require('multiaddr');
var Libp2pNode = require('libp2p-ipfs').Node;
var mafmt = require('mafmt');

var OFFLINE_ERROR = require('../utils').OFFLINE_ERROR;

module.exports = function libp2p(self) {
  // NOTE: TODO CONSIDER/ CONSIDERING putting all of libp2p (start, stop, peerbook and so on) inside the libp2p object and reduce one layer

  return {
    start: function start(callback) {
      self._libp2pNode = new Libp2pNode(self._peerInfo);
      self._libp2pNode.start(function () {
        // TODO connect to bootstrap nodes, it will get us more addrs
        self._libp2pNode.peerInfo.multiaddrs.forEach(function (ma) {
          console.log('Swarm listening on', ma.toString());
        });
        callback();
      });

      self._libp2pNode.discovery.on('peer', function (peerInfo) {
        self._libp2pNode.peerBook.put(peerInfo);
        self._libp2pNode.dialByPeerInfo(peerInfo, function () {});
      });
      self._libp2pNode.swarm.on('peer-mux-established', function (peerInfo) {
        self._libp2pNode.peerBook.put(peerInfo);
      });
    },
    stop: function stop(callback) {
      self._libp2pNode.stop(callback);
    },
    swarm: {
      peers: function peers(callback) {
        if (!self.isOnline()) {
          return callback(OFFLINE_ERROR);
        }

        callback(null, self._libp2pNode.peerBook.getAll());
      },
      // all the addrs we know
      addrs: function addrs(callback) {
        if (!self.isOnline()) {
          return callback(OFFLINE_ERROR);
        }
        // TODO
        throw new Error('Not implemented');
      },
      localAddrs: function localAddrs(callback) {
        if (!self.isOnline()) {
          return callback(OFFLINE_ERROR);
        }

        callback(null, self._libp2pNode.peerInfo.multiaddrs);
      },
      connect: function connect(maddr, callback) {
        if (!self.isOnline()) {
          return callback(OFFLINE_ERROR);
        }

        if (typeof maddr === 'string') {
          maddr = multiaddr(maddr);
        }

        if (!mafmt.IPFS.matches(maddr.toString())) {
          return callback(new Error('multiaddr not valid'));
        }

        var ipfsIdB58String = void 0;
        maddr.stringTuples().forEach(function (tuple) {
          if (tuple[0] === 421) {
            ipfsIdB58String = tuple[1];
          }
        });

        var id = peerId.createFromB58String(ipfsIdB58String);

        self._libp2pNode.dialByMultiaddr(maddr, function (err) {
          callback(err, id);
        });
      },
      disconnect: function disconnect(maddr, callback) {
        if (!self.isOnline()) {
          return callback(OFFLINE_ERROR);
        }

        if (typeof maddr === 'string') {
          maddr = multiaddr(maddr);
        }

        self._libp2pNode.hangUpByMultiaddr(maddr, callback);
      },
      filters: function filters() {
        // TODO
        throw new Error('Not implemented');
      }
    },
    routing: {},
    records: {},
    ping: function ping() {
      throw new Error('Not implemented');
    }
  };
};