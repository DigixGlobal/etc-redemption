'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var mDAG = require('ipfs-merkle-dag');
var waterfall = require('run-waterfall');
var promisify = require('promisify-es6');
var bs58 = require('bs58');
var DAGNode = mDAG.DAGNode;
var DAGLink = mDAG.DAGLink;

function normalizeMultihash(multihash, enc) {
  if (typeof multihash === 'string') {
    if (enc === 'base58') {
      return multihash;
    }

    return new Buffer(multihash, enc);
  } else if (Buffer.isBuffer(multihash)) {
    return multihash;
  } else {
    throw new Error('unsupported multihash');
  }
}

function parseBuffer(buf, encoding) {
  switch (encoding) {
    case 'json':
      return parseJSONBuffer(buf);
    case 'protobuf':
      return parseProtoBuffer(buf);
    default:
      throw new Error('unkown encoding: ' + encoding);
  }
}

function parseJSONBuffer(buf) {
  try {
    var parsed = JSON.parse(buf.toString());
    var links = (parsed.Links || []).map(function (link) {
      return new DAGLink(link.Name, link.Size, new Buffer(bs58.decode(link.Hash)));
    });
    return new DAGNode(new Buffer(parsed.Data), links);
  } catch (err) {
    throw new Error('failed to parse JSON: ' + err);
  }
}

function parseProtoBuffer(buf) {
  var node = new DAGNode();
  node.unMarshal(buf);
  return node;
}

module.exports = function object(self) {
  function editAndSave(edit) {
    return function (multihash, options, cb) {
      if (typeof options === 'function') {
        cb = options;
        options = {};
      }

      waterfall([function (cb) {
        return self.object.get(multihash, options, cb);
      }, function (node, cb) {
        self._dagS.add(edit(node), function (err) {
          cb(err, node);
        });
      }], function (err, node) {
        if (err) {
          return cb(err);
        }
        cb(null, node);
      });
    };
  }

  return {
    new: promisify(function (cb) {
      var node = new DAGNode();

      self._dagS.add(node, function (err) {
        if (err) {
          return cb(err);
        }

        cb(null, node);
      });
    }),

    put: promisify(function (obj, options, cb) {
      if (typeof options === 'function') {
        cb = options;
        options = {};
      }

      var encoding = options.enc;
      var node = void 0;

      if (Buffer.isBuffer(obj)) {
        if (encoding) {
          try {
            node = parseBuffer(obj, encoding);
          } catch (err) {
            return cb(err);
          }
        } else {
          node = new DAGNode(obj);
        }
      } else if (obj.multihash) {
        // already a dag node
        node = obj;
      } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
        node = new DAGNode(obj.Data, obj.Links);
      } else {
        return cb(new Error('obj not recognized'));
      }

      self._dagS.add(node, function (err, block) {
        if (err) {
          return cb(err);
        }

        self.object.get(node.multihash(), cb);
      });
    }),

    get: promisify(function (multihash, options, cb) {
      if (typeof options === 'function') {
        cb = options;
        options = {};
      }

      var mh = void 0;

      try {
        mh = normalizeMultihash(multihash, options.enc);
      } catch (err) {
        return cb(err);
      }

      self._dagS.get(mh, cb);
    }),

    data: promisify(function (multihash, options, cb) {
      if (typeof options === 'function') {
        cb = options;
        options = {};
      }

      self.object.get(multihash, options, function (err, node) {
        if (err) {
          return cb(err);
        }

        cb(null, node.data);
      });
    }),

    links: promisify(function (multihash, options, cb) {
      if (typeof options === 'function') {
        cb = options;
        options = {};
      }

      self.object.get(multihash, options, function (err, node) {
        if (err) {
          return cb(err);
        }

        cb(null, node.links);
      });
    }),

    stat: promisify(function (multihash, options, cb) {
      if (typeof options === 'function') {
        cb = options;
        options = {};
      }

      self.object.get(multihash, options, function (err, node) {
        if (err) {
          return cb(err);
        }

        var blockSize = node.marshal().length;
        var linkLength = node.links.reduce(function (a, l) {
          return a + l.size;
        }, 0);

        cb(null, {
          Hash: node.toJSON().Hash,
          NumLinks: node.links.length,
          BlockSize: blockSize,
          LinksSize: blockSize - node.data.length,
          DataSize: node.data.length,
          CumulativeSize: blockSize + linkLength
        });
      });
    }),

    patch: promisify({
      addLink: function addLink(multihash, link, options, cb) {
        editAndSave(function (node) {
          node.addRawLink(link);
          return node;
        })(multihash, options, cb);
      },
      rmLink: function rmLink(multihash, linkRef, options, cb) {
        editAndSave(function (node) {
          node.links = node.links.filter(function (link) {
            if (typeof linkRef === 'string') {
              return link.name !== linkRef;
            }

            if (Buffer.isBuffer(linkRef)) {
              return !link.hash.equals(linkRef);
            }

            if (linkRef.name) {
              return link.name !== linkRef.name;
            }

            return !link.hash.equals(linkRef.hash);
          });
          return node;
        })(multihash, options, cb);
      },
      appendData: function appendData(multihash, data, options, cb) {
        editAndSave(function (node) {
          node.data = Buffer.concat([node.data, data]);
          return node;
        })(multihash, options, cb);
      },
      setData: function setData(multihash, data, options, cb) {
        editAndSave(function (node) {
          node.data = data;
          return node;
        })(multihash, options, cb);
      }
    })
  };
};