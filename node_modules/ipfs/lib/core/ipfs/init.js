'use strict';

var peerId = require('peer-id');
var BlockService = require('ipfs-block-service');
var DagService = require('ipfs-merkle-dag').DAGService;
var path = require('path');
var glob = require('glob');
var parallelLimit = require('run-parallel-limit');
var Readable = require('stream').Readable;
var fs = require('fs');
var Importer = require('ipfs-unixfs-engine').importer;

module.exports = function init(self) {
  return function (opts, callback) {
    opts = opts || {};
    opts.emptyRepo = opts.emptyRepo || false;
    opts.bits = opts.bits || 2048;

    // Pre-set config values.
    var config = JSON.parse(fs.readFileSync(path.join(__dirname, '../../init-files/default-config.json')).toString());

    // Verify repo does not yet exist.
    self._repo.exists(function (err, exists) {
      if (err) {
        return callback(err);
      }

      if (exists === true) {
        return callback(new Error('repo already exists'));
      }

      generateAndSetKeypair();
    });

    // Generate peer identity keypair + transform to desired format + add to config.
    function generateAndSetKeypair() {
      var keys = peerId.create({
        bits: opts.bits
      });
      config.Identity = {
        PeerID: keys.toB58String(),
        PrivKey: keys.privKey.bytes.toString('base64')
      };

      writeVersion();
    }

    function writeVersion() {
      var version = '3';

      self._repo.version.set(version, function (err) {
        if (err) {
          return callback(err);
        }

        writeConfig();
      });
    }

    // Write the config to the repo.
    function writeConfig() {
      self._repo.config.set(config, function (err) {
        if (err) {
          return callback(err);
        }

        addDefaultAssets();
      });
    }

    // Add the default assets to the repo.
    function addDefaultAssets() {
      // Skip this step on the browser, or if emptyRepo was supplied.
      var isNode = require('detect-node');
      if (!isNode || opts.emptyRepo) {
        return doneImport(null);
      }

      var blocks = new BlockService(self._repo);
      var dag = new DagService(blocks);

      var initDocsPath = path.join(__dirname, '../../init-files/init-docs');

      var i = new Importer(dag);
      i.resume();

      glob(path.join(initDocsPath, '/**/*'), function (err, res) {
        if (err) {
          throw err;
        }
        var index = __dirname.lastIndexOf('/');
        parallelLimit(res.map(function (element) {
          return function (callback) {
            var addPath = element.substring(index + 1, element.length);
            if (!fs.statSync(element).isDirectory()) {
              var rs = new Readable();
              rs.push(fs.readFileSync(element));
              rs.push(null);
              var filePair = { path: addPath, content: rs };
              i.write(filePair);
            }
            callback();
          };
        }), 10, function (err) {
          if (err) {
            throw err;
          }
          i.end();
        });
      });

      i.once('end', function () {
        doneImport(null);
      });

      function doneImport(err, stat) {
        if (err) {
          return callback(err);
        }

        // All finished!
        callback(null, true);
      }
    }
  };
};