'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var mh = require('multihashes');
var multibase = require('multibase');
var multicodec = require('multicodec');

var codecs = require('./codecs');

// CID: <mbase><version><mcodec><mhash>

var CID = function () {
  /*
   * if (str)
   *   if (1st char is on multibase table) -> CID String
   *   else -> bs58 encoded multihash
   * else if (Buffer)
   *   if (0 or 1) -> CID
   *   else -> multihash
   * else if (Number)
   *   -> construct CID by parts
   *
   * ..if only JS had traits..
   */
  function CID(version, codec, multihash) {
    _classCallCheck(this, CID);

    if (typeof version === 'string') {
      if (multibase.isEncoded(version)) {
        // CID String (encoded with multibase)
        var cid = multibase.decode(version);
        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16);
        this.codec = multicodec.getCodec(cid.slice(1));
        this.multihash = multicodec.rmPrefix(cid.slice(1));
      } else {
        // bs58 string encoded multihash
        this.codec = 'dag-pb';
        this.multihash = mh.fromB58String(version);
        this.version = 0;
      }
    } else if (Buffer.isBuffer(version)) {
      var firstByte = version.slice(0, 1);
      var v = parseInt(firstByte.toString('hex'), 16);
      if (v === 0 || v === 1) {
        // CID
        var _cid = version;
        this.version = v;
        this.codec = multicodec.getCodec(_cid.slice(1));
        this.multihash = multicodec.rmPrefix(_cid.slice(1));
      } else {
        // multihash
        this.codec = 'dag-pb';
        this.multihash = version;
        this.version = 0;
      }
    } else if (typeof version === 'number') {
      if (typeof codec !== 'string') {
        throw new Error('codec must be string');
      }
      if (!(version === 0 || version === 1)) {
        throw new Error('version must be a number equal to 0 or 1');
      }
      mh.validate(multihash);
      this.codec = codec;
      this.version = version;
      this.multihash = multihash;
    }
  }

  _createClass(CID, [{
    key: 'toV0',
    value: function toV0() {
      return this.multihash;
    }
  }, {
    key: 'toV1',
    value: function toV1() {
      return this.buffer;
    }

    /* defaults to base58btc */

  }, {
    key: 'toBaseEncodedString',
    value: function toBaseEncodedString(base) {
      base = base || 'base58btc';

      switch (this.version) {
        case 0:
          return mh.toB58String(this.multihash);
        case 1:
          return multibase.encode(base, this.buffer).toString();
        default:
          throw new Error('Unsupported version');
      }
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        codec: this.codec,
        version: this.version,
        hash: this.multihash
      };
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      return this.codec === other.codec && this.version === other.version && this.multihash.equals(other.multihash);
    }
  }, {
    key: 'buffer',
    get: function get() {
      switch (this.version) {
        case 0:
          return this.multihash;
        case 1:
          return Buffer.concat([Buffer('01', 'hex'), Buffer(codecs[this.codec]), this.multihash]);
        default:
          throw new Error('unsupported version');
      }
    }
  }]);

  return CID;
}();

CID.codecs = codecs;
CID.isCID = function (other) {
  return other.constructor.name === 'CID';
};

module.exports = CID;